---
title: "Prior elicitation"
author: "Lorenzo Gaborini"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Prior elicitation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

suppressPackageStartupMessages(library(here))

source(here('vignettes', 'knitr_markup.R'))
bmatrix.digits <- 4
```

## Test case

```{r}
set.seed(1337)

library(bayessource)
requireNamespace('mvtnorm')
```


Let's generate a test dataset with known parameters.      
We will use some supporting functions:

```{r}
# Generate n random integers in {min, ..., max}
randi <- function(n, min, max) { round(runif(n, min, max)) }

#' Generate random invertible symmetric pxp matrix
#'
#' @param p matrix size
#' @param alpha regularization > 0
randinvmat <- function(p, M = 5, alpha = NULL) {
  stopifnot(p > 0)
  stopifnot(M > 0)
  if (is.null(alpha)) {
    alpha <- p + 1
  } else {
    stopifnot(alpha > 0)
  }
  M * stats::rWishart(1, p + alpha, diag(p))[,,1]/(p + alpha)
}

# Compute inverse of X if X is sympd
solve_sympd <- function(X) {
  chol2inv(chol(X))
}
```
## Data generation

We will generate the data according to the model: for sources $i = 1, \ldots, m$,

$$X_{ij} \; | \; \theta_i, \; W_i \sim \quad N_p(\theta_i, W_i) \quad \forall j = 1, \ldots, n $$
$$\theta_i \; | \; \mu, B \sim \quad N_p(\mu, B)$$
$$W_i \; | \; U, n_w \sim \quad IW(U, n_w)$$

```{r}
p <- 4      # number of variables
m <- 100     # number of sources
n <- 5000     # number of items per source
```

Upper hierarchical level: generate $\mu$, $n_w$, $B$, $U$

```{r}
list_exact <- list()
list_exact$B.exact <- randinvmat(p, alpha=2)      # Between Covariance matrix
list_exact$U.exact <- randinvmat(p, alpha=2)      # Inverted Wishart parameter
list_exact$mu.exact <- randi(p, 0, 10)   # mean of means
list_exact$nw.exact <- 2*(p + 1) + 1     # dof for Inverted Wishart, as small as possible
```

Middle hierarchical level: for every source generate

- source means: $\theta_i$
- within covariance matrices: $W_i$

```{r}
theta.sources.exact <- list()
for (i in seq(m)) {
  theta.sources.exact[[i]] <- mvtnorm::rmvnorm(1, list_exact$mu.exact, list_exact$B.exact)
}
W.sources.exact <- list()
for (i in seq(m)) {
  # Equivalents:
  # W.sources.exact[[i]] <- solve(rWishart(1, nw.exact, solve(U.exact))[,,1])
  W.sources.exact[[i]] <- bayessource::riwish_Press(list_exact$nw.exact, list_exact$U.exact)
}
```

Lower hierarchical level: raw data from every source

```{r}
df <- list()
for (i in seq(m)) {
  # The data
  df[[i]] <- mvtnorm::rmvnorm(n, theta.sources.exact[[i]], W.sources.exact[[i]])
  # The source (last column)
  df[[i]] <- cbind(df[[i]], i)
}

df <- data.frame(do.call(rbind, df))
colnames(df) <- paste(c(paste0('v', seq(1:p)), 'source'))
```

The item column is the last one (`p + 1`).

### Visualization

First two components across sources:

```{r example-plot, fig.width=8}
library(ggplot2)
suppressPackageStartupMessages(library(dplyr))

df %>% 
  sample_frac(0.25) %>% 
  ggplot(aes(x = v1, y = v2, col = factor(source))) +
  geom_point(size = 1, show.legend = FALSE) +
  labs(x = 'x1', y = 'x2', title = 'Raw data across sources: first two components', 
       subtitle = paste('Color = source; ', m, 'sources, ', n, 'observations per source'))
```

## Prior elicitation

The package supplies the function `make_priors_and_init`.

Suppose that `df` represents a background dataset.  
We can use it to elicit the model hyperparameters:

```{r}
col.variables <- 1:p
col.item <- p + 1

use.priors <- 'ML'
use.init <- 'random'

priors <- make_priors_and_init(df, col.variables, col.item, use.priors, use.init)
names(priors)
```


### Hyperpriors on mean

- hyperprior for the between mean $\mu$

```{r, results='asis'}
bmatrix(as.matrix(priors$mu), pre = '\\mu =', digits = bmatrix.digits)
```

Exact: 

```{r, results='asis'}
bmatrix(as.matrix(list_exact$mu.exact), pre = '\\mu =', digits = bmatrix.digits)
```

- Hyperprior for the between covariance matrix $B$:

```{r, results='asis'}
bmatrix(priors$B.inv, pre = 'B^{-1} =', digits = bmatrix.digits)
```

Exact: 

```{r, results='asis'}
bmatrix(solve_sympd(list_exact$B.exact), pre = 'B^{-1} =', digits = bmatrix.digits)
```

### Hyperpriors on within covariance matrix

- Inverse of Inverted Wishart scale matrix:

$$ W_i \sim IW(n_w, U) $$
$$ n_w = `r priors$nw` $$

```{r, results='asis'}
bmatrix(priors$U, pre = 'U =', digits = bmatrix.digits)
```

Exact: 

```{r, results='asis'}
bmatrix(list_exact$U.exact, pre = 'U =', digits = bmatrix.digits)
```

## Initialisation

Within covariance matrices and their inverses: we initialize the chain with

```{r, results='asis'}
bmatrix(priors$W.inv.1, pre = 'W^{-1}_1 =', digits = bmatrix.digits)
bmatrix(priors$W.inv.2, pre = 'W^{-1}_2 =', digits = bmatrix.digits)
```

## Usage

The list returned by `make_priors_and_init` can be used in calls to `marginalLikelihood` and `samesource_C`:

```{r, eval=FALSE}
priors <- make_priors_and_init(df, col.variables, col.item, use.priors, use.init)

mtx_data <- as.matrix(df[, col.variables])

ml <- marginalLikelihood(X = mtx_data, n.iter = 1000, burn.in = 100,
                   B.inv = priors$B.inv, 
                   W.inv = priors$W.inv.1, 
                   U = priors$U, 
                   nw = priors$nw, 
                   mu = priors$mu)
```


