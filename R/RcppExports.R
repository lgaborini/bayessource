# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Check whether Cholesky speedup is used.
#' @keywords internal
isCholeskyOn <- function() {
    .Call('_bayessource_isCholeskyOn', PACKAGE = 'bayessource')
}

#' Fast Bayesian same source hypothesis. Gaussian MV.
#' To be called by the R wrapper.
#'
#' @param X the dataset
#' @param n_iter number of MC iterations
#' @param B_inv prior inverse of between covariance matrix
#' @param W_inv initialization for prior inverse of within covariance matrix
#' @param U covariance matrix for the mean
#' @param nw degrees of freedom
#' @param mu prior mean
#' @param burn_in burn-in iterations
#' @param chain_output if true, output the entire chain as a list (ML-value, samples from theta, samples from W_inv)
#' @param verbose if TRUE, be verbose
#' @param Gibbs_only if TRUE, only return the Gibbs posterior samples. Implies chain_output = TRUE.
#'
#' @template gaussmv_model
#' @keywords internal
marginalLikelihood_internal <- function(X, n_iter, B_inv, W_inv, U, nw, mu, burn_in, chain_output = FALSE, verbose = FALSE, Gibbs_only = FALSE) {
    .Call('_bayessource_marginalLikelihood_internal', PACKAGE = 'bayessource', X, n_iter, B_inv, W_inv, U, nw, mu, burn_in, chain_output, verbose, Gibbs_only)
}

#' Computes \eqn{log( sum_i( exp(v[i] )) )} in a stable way.
#'
#' @keywords internal
logSumExp <- function(v) {
    .Call('_bayessource_logSumExp', PACKAGE = 'bayessource', v)
}

#' Computes \eqn{log( sum_i( exp(v[i] )) ) - log(n)} in a stable way.
#'
#' @keywords internal
logSumExpMean <- function(v) {
    .Call('_bayessource_logSumExpMean', PACKAGE = 'bayessource', v)
}

#' Computes log( cumsum_i( exp(v[i]) ) ) in a stable way.
#'
#' @keywords internal
logCumsumExp <- function(v) {
    .Call('_bayessource_logCumsumExp', PACKAGE = 'bayessource', v)
}

#' Computes log( cummean_i( exp(v[i]) ) ) in a stable way.
#'
#' @keywords internal
logCummeanExp <- function(v) {
    .Call('_bayessource_logCummeanExp', PACKAGE = 'bayessource', v)
}

#' Upper triangular matrix inversion
#'
#' Quickly computes the inverse of a upper triangular matrix (e.g. a Cholesky factor).
#'
#' Equivalent R code:
#'
#' \code{X.chol.inv <- backsolve(r = X.chol, x = diag(p))}
#' @keywords internal
inv_triangular <- function(U) {
    .Call('_bayessource_inv_triangular', PACKAGE = 'bayessource', U)
}

#' Compute the inverse from the upper Cholesky factor
#'
#' @keywords internal
chol2inv <- function(U_chol) {
    .Call('_bayessource_chol2inv', PACKAGE = 'bayessource', U_chol)
}

#' Upper Cholesky factor of inverse from upper Cholesky factor
#'
#' If \eqn{A = U' U}, compute \eqn{V} where \eqn{A^{(-1)} = V' V}
#'
#' @keywords internal
inv_Cholesky_from_Cholesky <- function(U) {
    .Call('_bayessource_inv_Cholesky_from_Cholesky', PACKAGE = 'bayessource', U)
}

#' log-determinant from Cholesky factor
#'
#' If \eqn{A = U' U}, compute log(det(A)) from U
#'
#' @keywords internal
ldet_from_Cholesky <- function(T_chol) {
    .Call('_bayessource_ldet_from_Cholesky', PACKAGE = 'bayessource', T_chol)
}

#' Generate from multivariate normal.
#'
#' Faster than \code{rmvnorm} in package \pkg{mvtnorm}. Implemented in C.
#'
#' @param n amount of samples to generate from
#' @param mu column vector for the mean
#' @param Cov covariance matrix
#' @param is_chol if TRUE, Cov is the upper Cholesky factor of Cov
#' @return a nxp matrix of samples
#' 
#' @export
rmvnorm <- function(n, mu, Cov, is_chol = FALSE) {
    .Call('_bayessource_rmvnorm', PACKAGE = 'bayessource', n, mu, Cov, is_chol)
}

#' Multivariate normal density. Assumes symmetry.
#'
#' Faster than \code{dmvnorm} in package \pkg{mvtnorm}. Implemented in C.
#'
#' @param x the observation (nxp)
#' @param mean mean vector (row vector, 1xp)
#' @param Cov covariance matrix (pxp)
#' @param logd if TRUE, return the log-density
#' @param is_chol if TRUE, Cov is the upper Cholesky factor of Cov
#' @return the density in x (nx1)
#' 
#' @export
dmvnorm <- function(x, mean, Cov, logd = FALSE, is_chol = FALSE) {
    .Call('_bayessource_dmvnorm', PACKAGE = 'bayessource', x, mean, Cov, logd, is_chol)
}

#' Generate random sample from Wishart (faster).
#'
#' Same code as \code{\link[stats]{rWishart}} function in package \pkg{stats}.
#'
#' @param v dof
#' @param S the scale matrix (pxp)
#' @param is_chol if TRUE, S is the upper Cholesky factor of S
#' @param return_chol if TRUE, the upper Cholesky factor is returned
#' @return a single random variate from W(v, S)
#' 
#' @export
#' @template Wishart_eqn
rwish <- function(v, S, is_chol = FALSE, return_chol = FALSE) {
    .Call('_bayessource_rwish', PACKAGE = 'bayessource', v, S, is_chol, return_chol)
}

#' Inverted Wishart density from the inverse (faster).
#'
#' Computes the density of an Inverted Wishart (df, Sigma) in X, by supplying (X^(-1), df, Sigma) rather than (X, df, Sigma).
#' Avoids a matrix inversion.
#'
#' Computes the pdf p_X(x) by knowing x^(-1)
#'
#' @param X_inv inverse of X (the observation)
#' @param df degrees of freedom
#' @param Sigma scale matrix
#' @param logd if TRUE, return the log-density
#' @param is_chol if TRUE, Sigma and X_inv are the upper Cholesky factors of Sigma and X.inv
#' 
#' @export
#' @template InverseWishart_Press
#' @seealso \code{\link{diwishart}}, \code{\link{dwishart}}
diwishart_inverse <- function(X_inv, df, Sigma, logd = FALSE, is_chol = FALSE) {
    .Call('_bayessource_diwishart_inverse', PACKAGE = 'bayessource', X_inv, df, Sigma, logd, is_chol)
}

